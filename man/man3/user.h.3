.TH "src/cparse/user.h" 3 "Mon Nov 2 2015" "Version 0.1" "cParse" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/cparse/user.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <cparse/defines\&.h>\fP
.br
\fC#include <cparse/query\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "BEGIN_DECL \fBcParseUser\fP * \fBcparse_current_user\fP (\fBcParseError\fP **error)"
.br
.ti -1c
.RI "\fBcParseUser\fP * \fBcparse_user_new\fP ()"
.br
.ti -1c
.RI "\fBcParseUser\fP * \fBcparse_user_with_name\fP (const char *username)"
.br
.ti -1c
.RI "\fBcParseUser\fP * \fBcparse_user_login\fP (const char *username, const char *password, \fBcParseError\fP **error)"
.br
.ti -1c
.RI "\fBcparse_thread\fP \fBcparse_user_login_in_background\fP (const char *username, const char *password, \fBcParseObjectCallback\fP callback, void *param)"
.br
.ti -1c
.RI "void \fBcparse_user_logout\fP ()"
.br
.ti -1c
.RI "\fBcParseQuery\fP * \fBcparse_user_query_new\fP ()"
.br
.ti -1c
.RI "\fBbool\fP \fBcparse_user_sign_up\fP (\fBcParseUser\fP *user, const char *password, \fBcParseError\fP **error)"
.br
.ti -1c
.RI "\fBcparse_thread\fP \fBcparse_user_sign_up_in_background\fP (\fBcParseUser\fP *user, const char *password, \fBcParseObjectCallback\fP callback, void *param)"
.br
.ti -1c
.RI "const char * \fBcparse_user_name\fP (\fBcParseUser\fP *user)"
.br
.ti -1c
.RI "void \fBcparse_user_set_name\fP (\fBcParseUser\fP *user, const char *value)"
.br
.ti -1c
.RI "const char * \fBcparse_user_email\fP (\fBcParseUser\fP *user)"
.br
.ti -1c
.RI "const char * \fBcparse_user_session_token\fP (\fBcParseUser\fP *user)"
.br
.ti -1c
.RI "\fBcParseUser\fP * \fBcparse_user_validate\fP (const char *sessionToken, \fBcParseError\fP **error)"
.br
.ti -1c
.RI "\fBbool\fP \fBcparse_user_validate_email\fP (\fBcParseUser\fP *user, \fBcParseError\fP **error)"
.br
.ti -1c
.RI "\fBbool\fP \fBcparse_user_reset_password\fP (\fBcParseUser\fP *user, \fBcParseError\fP **error)"
.br
.ti -1c
.RI "\fBcparse_thread\fP \fBcparse_user_reset_password_in_background\fP (\fBcParseUser\fP *user, \fBcParseObjectCallback\fP callback, void *param)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "void(* \fBcparse_user_free\fP )(\fBcParseUser\fP *user)"
.br
.ti -1c
.RI "\fBbool\fP(* \fBcparse_user_delete\fP )(\fBcParseUser\fP *obj, \fBcParseError\fP **error)"
.br
.ti -1c
.RI "\fBcparse_thread\fP(* \fBcparse_user_delete_in_background\fP )(\fBcParseUser\fP *obj, \fBcParseObjectCallback\fP callback, void *param)"
.br
.ti -1c
.RI "\fBbool\fP(* \fBcparse_user_fetch\fP )(\fBcParseUser\fP *obj, \fBcParseError\fP **error)"
.br
.ti -1c
.RI "\fBcparse_thread\fP(* \fBcparse_user_fetch_in_background\fP )(\fBcParseUser\fP *obj, \fBcParseObjectCallback\fP callback, void *param)"
.br
.ti -1c
.RI "\fBbool\fP(* \fBcparse_user_refresh\fP )(\fBcParseUser\fP *obj, \fBcParseError\fP **error)"
.br
.ti -1c
.RI "\fBcparse_thread\fP(* \fBcparse_user_refresh_in_background\fP )(\fBcParseUser\fP *user, \fBcParseObjectCallback\fP callback, void *param)"
.br
.in -1c
.SH "Detailed Description"
.PP 
cParse User Functions for dealing with user objects 
.SH "Function Documentation"
.PP 
.SS "BEGIN_DECL \fBcParseUser\fP* cparse_current_user (\fBcParseError\fP ** error)"
gets the currently logged in user 
.PP
\fBReturns:\fP
.RS 4
the current logged in user instance or NULL 
.RE
.PP

.SS "const char* cparse_user_email (\fBcParseUser\fP * user)"
gets a user's email 
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP the user instance 
.RE
.PP
\fBReturns:\fP
.RS 4
the email as a string or NULL 
.RE
.PP

.SS "\fBcParseUser\fP* cparse_user_login (const char * username, const char * password, \fBcParseError\fP ** error)"
logs in as a user 
.PP
\fBParameters:\fP
.RS 4
\fIusername\fP the username of the user 
.br
\fIpassword\fP the password for the user 
.br
\fIerror\fP a pointer to an error that gets allocated if unsuccessful\&. can be NULL 
.RE
.PP
\fBReturns:\fP
.RS 4
the user object if successful, NULL otherwise 
.RE
.PP

.SS "\fBcparse_thread\fP cparse_user_login_in_background (const char * username, const char * password, \fBcParseObjectCallback\fP callback, void * param)"
logs in as a user in the background 
.PP
\fBParameters:\fP
.RS 4
\fIusername\fP the username of the user 
.br
\fIpassword\fP the password of the user 
.br
\fIcallback\fP the callback issued if successful 
.RE
.PP
\fBReturns:\fP
.RS 4
an identifier for the background thread 
.RE
.PP

.SS "void cparse_user_logout ()"
logs out the current user 
.SS "const char* cparse_user_name (\fBcParseUser\fP * user)"
gets the user name 
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP the user instance 
.RE
.PP
\fBReturns:\fP
.RS 4
the name as a string or NULL 
.RE
.PP

.SS "\fBcParseUser\fP* cparse_user_new ()"
allocates a new user object 
.PP
\fBReturns:\fP
.RS 4
the allocated user instance 
.RE
.PP

.SS "\fBcParseQuery\fP* cparse_user_query_new ()"
creates a new query for a user object 
.PP
\fBReturns:\fP
.RS 4
the query instance 
.RE
.PP

.SS "\fBbool\fP cparse_user_reset_password (\fBcParseUser\fP * user, \fBcParseError\fP ** error)"
resets a user's password 
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP the user to reset 
.br
\fIerror\fP the error to set on failure 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the users password was reset 
.RE
.PP

.SS "\fBcparse_thread\fP cparse_user_reset_password_in_background (\fBcParseUser\fP * user, \fBcParseObjectCallback\fP callback, void * param)"
resets a user's password in the background 
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP the user to reset 
.br
\fIcallback\fP the optional callback function 
.br
\fIparam\fP the optional user info for the callback function 
.RE
.PP
\fBReturns:\fP
.RS 4
a thread identifier 
.RE
.PP

.SS "const char* cparse_user_session_token (\fBcParseUser\fP * user)"
gets a user's session token 
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP the user instance 
.RE
.PP
\fBReturns:\fP
.RS 4
the session token as a string or NULL 
.RE
.PP

.SS "void cparse_user_set_name (\fBcParseUser\fP * user, const char * value)"
sets a user's name 
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP the user instance 
.br
\fIvalue\fP the string value 
.RE
.PP

.SS "\fBbool\fP cparse_user_sign_up (\fBcParseUser\fP * user, const char * password, \fBcParseError\fP ** error)"
Creates a new user on the backend 
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP the user instance 
.br
\fIpassword\fP the user's password 
.br
\fIerror\fP a pointer to an error that will get allocated if unsuccessful\&. Can be NULL\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true if successful\&. 
.RE
.PP

.SS "\fBcparse_thread\fP cparse_user_sign_up_in_background (\fBcParseUser\fP * user, const char * password, \fBcParseObjectCallback\fP callback, void * param)"
Creates a new user in the background 
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP the user instance 
.br
\fIpassword\fP the user's password 
.br
\fIcallback\fP the callback issued after signing up 
.RE
.PP
\fBReturns:\fP
.RS 4
an identifier for the background thread 
.RE
.PP

.SS "\fBcParseUser\fP* cparse_user_validate (const char * sessionToken, \fBcParseError\fP ** error)"
validates a session token against the backend 
.PP
\fBParameters:\fP
.RS 4
\fIsessionToken\fP the session token to validate 
.br
\fIerror\fP a pointer to an error that will get allocated if unsuccessful\&. Can be NULL\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true if successful 
.RE
.PP

.SS "\fBbool\fP cparse_user_validate_email (\fBcParseUser\fP * user, \fBcParseError\fP ** error)"
tests if the user has an 'emailVerified' parameter and its true\&. If the parameter does not exists a refresh from the server will be attempted\&. 
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP the user instance 
.br
\fIerror\fP a pointer to an error that will get allocated if unsuccessful\&. Can be NULL\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true if successful 
.RE
.PP

.SS "\fBcParseUser\fP* cparse_user_with_name (const char * username)"
allocates a new user with a user name 
.PP
\fBParameters:\fP
.RS 4
\fIusername\fP the username for the user 
.RE
.PP
\fBReturns:\fP
.RS 4
the allocated user instance 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "\fBbool\fP(* cparse_user_delete) (\fBcParseUser\fP *obj, \fBcParseError\fP **error)"
deletes a user 
.PP
\fBSee also:\fP
.RS 4
\fBcparse_object_delete\fP 
.RE
.PP

.SS "\fBcparse_thread\fP(* cparse_user_delete_in_background) (\fBcParseUser\fP *obj, \fBcParseObjectCallback\fP callback, void *param)"
deletes a user in the background 
.PP
\fBSee also:\fP
.RS 4
\fBcparse_object_delete_in_background\fP 
.RE
.PP

.SS "\fBbool\fP(* cparse_user_fetch) (\fBcParseUser\fP *obj, \fBcParseError\fP **error)"
fetch a user 
.PP
\fBSee also:\fP
.RS 4
\fBcparse_object_fetch\fP 
.RE
.PP

.SS "\fBcparse_thread\fP(* cparse_user_fetch_in_background) (\fBcParseUser\fP *obj, \fBcParseObjectCallback\fP callback, void *param)"
fetch a user in the background 
.PP
\fBSee also:\fP
.RS 4
\fBcparse_object_fetch_in_background\fP 
.RE
.PP

.SS "void(* cparse_user_free) (\fBcParseUser\fP *user)"
releases a user object from memory 
.PP
\fBSee also:\fP
.RS 4
\fBcparse_object_free\fP 
.RE
.PP

.SS "\fBbool\fP(* cparse_user_refresh) (\fBcParseUser\fP *obj, \fBcParseError\fP **error)"
refresh a user 
.PP
\fBSee also:\fP
.RS 4
\fBcparse_object_refresh\fP 
.RE
.PP

.SS "\fBcparse_thread\fP(* cparse_user_refresh_in_background) (\fBcParseUser\fP *user, \fBcParseObjectCallback\fP callback, void *param)"
refresh a user in the background 
.PP
\fBSee also:\fP
.RS 4
\fBcparse_object_refresh_in_background\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for cParse from the source code\&.
